这是一个基于你的原型实现及 Claude（作为用户）深度反馈整理的 **Intent-Engine 架构设计方案**。

这份文档采用了**朴素的工程师语言**，剥离了营销词汇，直击数据结构、状态流转和上下文管理策略。它非常适合用来与架构师进行核心技术对齐，阐述如何通过“外部状态机”解决 LLM 的长窗口健忘问题。

-----

# Intent-Engine 系统设计方案 (v1.0)

**核心定位**：面向 AI Agent 的**聚焦驱动 (Focus-Driven)** 长程任务状态机与外部记忆体。

## 1\. 设计愿景 (Design Philosophy)

解决 LLM 在长周期（Long-horizon）复杂任务中面临的 **“上下文遗忘”** 和 **“注意力稀释”** 问题。
如果不引入外部状态机，随着对话轮次增加，Prompt 信噪比（SNR）会呈指数级下降。Intent-Engine 通过将记忆“卸载”到外部结构化存储，实现：

  * **O(log n) 上下文消耗**：无论项目多大，AI 仅加载当前焦点的相关上下文。
  * **无状态会话的持久化**：即使 Session 重置，AI 也能通过 Event Sourcing 还原思维断点。

## 2\. 核心架构 (Core Architecture)

### 2.1 存储层：项目级嵌入式数据库

  * **选型**：SQLite + FTS5 (全文检索)。
  * **部署**：作为项目根目录下的文件（如 `.intent/db.sqlite`），随代码库分发，实现“记忆与代码同构”。

### 2.2 数据模型：树与流 (Tree & Stream)

系统由两个核心实体构成，分别对应“骨架”与“血肉”：

**A. Task Tree (结构化骨架)**

  * **结构**：Adjacency List 实现的多叉树。
  * **Schema**：`ID`, `Parent_ID`, `Status` (Pending/Active/Done), `Priority`.
  * **约束**：维护全局唯一的 `Current_Task_ID` 指针，模拟 CPU 的程序计数器 (PC)，强制 AI 单线程工作（一次只做一件事）。

**B. Event Stream (非结构化血肉)**

  * **结构**：挂载在特定 `Task_ID` 下的 Append-only Log。
  * **Schema**：`ID`, `Task_ID`, `Type`, `Content` (Text/Blob), `Timestamp`.
  * **关键类型 (Type)**：
      * `decision`: 架构决策、方案权衡（记录 "Why"，解决决策不可追溯问题）。
      * `note`: 调研笔记、排查中间状态（Context）。
      * `blocker`: 依赖卡点。
      * `milestone`: 阶段性成果。

## 3\. 核心机制：Focus-Driven Context (聚焦驱动上下文)

这是本设计的核心差异化优势（Secret Sauce）。当 AI `start` 一个特定任务（节点 $T$）时，Intent-Engine **动态构建** Prompt，而非 dump 整个数据库：

$$Context(T) = Ancestors(T) + Siblings(T) + Events(T)$$

1.  **Ancestors (溯源)**：Root 到 $T$ 的路径摘要。提供**宏观战略目标**，防止跑偏。
2.  **Siblings (广度)**：$T$ 的兄弟节点摘要。提供**协作边界**，知道平行任务在做什么，避免冲突。
3.  **Events (深度)**：$T$ 自身的完整 Event 历史。提供**执行细节**。
4.  **Pruning (剪枝)**：**剔除**所有已完成的非直系分支、无关子树。

**收益**：将线性增长的项目历史复杂度，降低为树深度的对数级复杂度 $O(\log N + k)$。

## 4\. 交互协议与工作流 (Interface & Workflow)

### 4.1 CLI / MCP 接口设计

基于 UNIX 哲学设计，支持流式操作，适应 AI Tool Use 习惯。

  * **Atomic Operations**:
      * `task_spawn`: 遇到复杂问题，动态拆解子任务，不急于写代码。
      * `task_done`: **无参调用**。直接结算当前 `Current_Task`，Cursor 自动弹回（Pop）父节点，符合心流。
  * **Pipe-Friendly (针对反馈优化)**:
      * 支持 `stdin` 输入：`ie event add --type note --data-stdin << 'EOF' ... EOF`。
      * **价值**：允许 AI 直接将代码分析、报错日志“管道化”存入记忆，无需创建临时文件 (`/tmp/analysis.md`)，保持工作区洁净。

### 4.2 递归 Agent 模式 (Recursive Agency)

  * **操作流**：`Task Start` -\> `Context Load` -\> `Spawn Sub-process`。
  * **实现**：利用 Claude `-p` 模式或启动新的 Sub-agent。
  * **机制**：子进程继承“剪枝后”的 Context，独立执行，完成后退出。父进程仅通过数据库状态感知结果。

## 5\. 系统边界定义 (System Boundaries)

为了清晰架构，必须明确 Intent-Engine **不是什么**：

| 维度 | **Intent-Engine** (思维层) | Git / Codebase (物理层) | Code Comments (说明层) |
| :--- | :--- | :--- | :--- |
| **存储内容** | **Why & Process** <br>(决策树、踩坑记录、调研过程) | **What & Result** <br>(最终代码产物、Diff) | **How & Logic** <br>(函数/算法解释) |
| **生命周期** | 跨 Session，伴随整个开发周期 | 伴随版本发布 (Commit) | 伴随代码维护 |
| **检索方式** | 语义搜索 (Vector/FTS) | 文件路径 / Grep | 阅读源码 |
| **服务对象** | **AI Agent 自身** (未来的 Sub-agent) | 编译器 / CI | 人类开发者 |

## 6\. 总结 (Summary)

Intent-Engine 本质上是一个 **面向 LLM 的认知文件系统与进程调度器**。

  * **Task Tree** 是它的目录结构（Directory Structure）。
  * **Event Stream** 是它的系统日志（Syslog）。
  * **Focus-Driven** 是它的虚拟内存管理（Virtual Memory Paging）。

它通过**结构化数据**和**动态上下文注入**，将 LLM 的“无状态流式生成”能力转化为“有状态的工程执行”能力，真正实现了**机器的长期记忆**。